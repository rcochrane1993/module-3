1.A binary search tree is a tree in which the left node is always a lesser value, while the right node is
always a greater value.This makes it unique from other trees where the left or right nodes don't have contrictions

2. a heuristic is a "guess" made my a computer through an algorithm in order to increase efficiency
and avoid finding all possible answers and choosing the right one.

3. another problem requiring heuristics could be a hacker trying to find the pin number of a credit card number he 
acquired.

4.a depth-first search searches all the way down a tree for as long as possible for each branch
while a breath-first search does the opposit and checks all the neighboring nodes before moving to the 
next level down in the tree.

5. An undirected,a-cyclic, unweighted graph is a graph that does not specify direction of travel, cannot form
a closed loop, and there is no assigned "travel-cost" for going between nodes.

6.a binary search tree could be an undirected,a-cyclic,weighted graph




PROGRAMMING QUESTIONS
1&2
class Tree{
  constructor(){
    this.root = null;
    this.count = 0;
    
  }
    
    addNode(node,newNode){
      if (newNode.value > node.value){
        if(node.right !== null){
          this.addNode(node.right,newNode)
        } else {
          node.right = newNode
        }
      } else if (newNode.value < node.value){
        if(node.left){
          this.addNode(node.left,newNode)
        } else {
          node.left = newNode
        }
      }
    }

    createNode(value){
      let node = {value: value, right:null,left:null}
      if (this.root ===null){
        this.root = node
      } else {
        this.addNode(this.root,node)
      }
  }

    
    search(item){
      let node = this.root
      while (node){
      if (node.value === item){
        return true
      } else if(item < node.value){
        node = node.left
      }else if (item > node.value){
        node = node.right
      }  
    }
    return false
  }
   
   
  distanceToRoot(node){
    this.count++
    if(node===null){
      return false
    }
    if(node < this.root.value){
     return this.distanceToRoot(node.left)
    }
    if (node > this.root.value){
      return this.distanceToRoot(node.right)
    }  
    return this.count 
  }

}

var newTree = new Tree;
newTree.createNode(8)
newTree.createNode(10)
newTree.createNode(3)
newTree.createNode(2)
newTree.createNode(1)
newTree.createNode(5)
newTree.createNode(9)
newTree.createNode(14)

console.log(newTree.distanceToRoot(10))